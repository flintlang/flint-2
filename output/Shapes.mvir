module Shapes {
  import 0x0.LibraCoin;
  import 0x0.LibraAccount;
  import 0x0.Vector;
  resource T {
    rectangle: Self.Rectangle
  }
  resource Libra {
    libra: Self.Libra_Coin
  }
  struct Rectangle {
    width: u64,
    height: u64
  }
  
  resource Libra_Coin {
    coin: LibraCoin.T
  }
  new(_rectangle: u64): Self.T { let __this_rectangle: Self.Rectangle;
    let _caller: address;
    _caller = get_txn_sender();
    __this_rectangle = Self.Rectangle_init((2 * copy(_rectangle)), copy(_rectangle));
    return T {
      rectangle: move(__this_rectangle) }; }
  
  public publish(_rectangle: u64) {
    move_to_sender<T>(Self.new(move(_rectangle)));
    return;
  }
  
  publicLibra(): Self.Libra {
    
    let __this_libra: Self.Libra_Coin;
    __this_libra = Self.Libra_Coin_init(0x0000000000000000000000000000000000000000);
    return Libra {
      libra: move(__this_libra) };
    
  }
  
  public Libra_balance (this: &mut Self.Libra): u64  {
    let ret: u64;
    let _temp__3: &mut Self.Libra_Coin;
    _temp__3 = &mut copy(this).libra;
    ret = Self.Libra_Coin_getValue(copy(_temp__3));
    _ = move(_temp__3);
    _ = move(this);
    return move(ret);
  }
  
  Libra_transfer (this: &mut Self.Libra, _to: &mut Self.Libra, _amount: u64)  {
    let _temp__5: &mut Self.Libra_Coin;
    let _temp__7: &mut Self.Libra_Coin;
    _temp__5 = &mut copy(this).libra;
    _temp__7 = &mut copy(_to).libra;
    Self.Libra_Coin_transfer(copy(_temp__5), copy(_temp__7), copy(_amount));
    _ = move(_temp__5);
    _ = move(_temp__7);
    _ = move(this);
    _ = move(_to);
    return;
  }
  
  Libra_transfer_value (this: &mut Self.Libra, _to: Self.Libra)  {
    let _temp__4: &mut Self.Libra_Coin;
    _temp__4 = &mut copy(this).libra;
    Self.Libra_Coin_transfer_value(copy(_temp__4), move(_to));
    _ = move(_temp__4);
    _ = move(this);
    return;
  }
  
  
  
  Quartz_Global_send (_address: address, _value: u64, _coin: &mut Self.Libra)  {
    Self.Quartz_Libra_send(copy(_coin), copy(_address), copy(_value));
    _ = move(_coin);
    return;
  }
  
  publicRectangle(_width: u64, _height: u64): Self.Rectangle {
    
    let __this_width: u64;
    let __this_height: u64;
    __this_width = copy(_width);
    __this_height = copy(_height);
    return Rectangle {
      width: move(__this_width),
      height: move(__this_height) };
    
  }
  
  public Rectangle_diagonal (this: &mut Self.Rectangle, _wideness: u64, _tallness: u64): u64  {
    let ret: u64;
    ret = (((copy(_wideness) ** 2) + (copy(_tallness) ** 2)) ** 0);
    _ = move(this);
    return move(ret);
  }
  Shapes_area (this: &mut Self.T): u64  {
    let ret: u64;
    let _caller: address;
    let _temp__4: &mut Self.Rectangle;
    _caller = get_txn_sender();
    _temp__4 = &mut copy(this).rectangle;
    ret = (*&mut copy(_temp__4).width * *&mut copy(_temp__4).height);
    _ = move(_temp__4);
    _ = move(this);
    return move(ret);
  }
  
  public area (__address_this: address): u64 acquires T {
    let ret: u64;
    let this: &mut Self.T;
    this = borrow_global_mut<T>(move(__address_this));
    ret = Self.Shapes_area(copy(this));
    _ = move(this);
    return move(ret);
  }
  
  Shapes_semiPerimeter (this: &mut Self.T): u64  {
    let ret: u64;
    let _caller: address;
    let _temp__4: &mut Self.Rectangle;
    _caller = get_txn_sender();
    _temp__4 = &mut copy(this).rectangle;
    ret = (*&mut copy(_temp__4).width + *&mut copy(_temp__4).height);
    _ = move(_temp__4);
    _ = move(this);
    return move(ret);
  }
  
  public semiPerimeter (__address_this: address): u64 acquires T {
    let ret: u64;
    let this: &mut Self.T;
    this = borrow_global_mut<T>(move(__address_this));
    ret = Self.Shapes_semiPerimeter(copy(this));
    _ = move(this);
    return move(ret);
  }
  
  Shapes_perimeter (this: &mut Self.T): u64  {
    let ret: u64;
    let _caller: address;
    let _temp__4: &mut Self.Rectangle;
    let _temp__6: &mut Self.Rectangle;
    _caller = get_txn_sender();
    _temp__4 = &mut copy(this).rectangle;
    _temp__6 = &mut copy(_temp__4).rectangle;
    ret = (2 * Self.Shapes_semiPerimeter(copy(_temp__6)));
    _ = move(_temp__4);
    _ = move(_temp__6);
    _ = move(this);
    return move(ret);
  }
  
  public perimeter (__address_this: address): u64 acquires T {
    let ret: u64;
    let this: &mut Self.T;
    this = borrow_global_mut<T>(move(__address_this));
    ret = Self.Shapes_perimeter(copy(this));
    _ = move(this);
    return move(ret);
  }
  
  Shapes_smallerWidth (this: &mut Self.T, _otherRectWidth: u64): bool  {
    let ret: bool;
    let _caller: address;
    let _temp__5: &mut Self.Rectangle;
    _caller = get_txn_sender();
    _temp__5 = &mut copy(this).rectangle;
    ret = (*&mut copy(_temp__5).width < copy(_otherRectWidth));
    _ = move(_temp__5);
    _ = move(this);
    return move(ret);
  }
  
  public smallerWidth (__address_this: address, _otherRectWidth: u64): bool acquires T {
    let ret: bool;
    let this: &mut Self.T;
    this = borrow_global_mut<T>(move(__address_this));
    ret = Self.Shapes_smallerWidth(copy(this), copy(_otherRectWidth));
    _ = move(this);
    return move(ret);
  }
  Quartz_RevertIfGreater(a: u64, b: u64): u64 {
    assert(copy(a) <= move(b), 1);
    return move(a);
  }
  
  
  
  _GetFromArrayInt(vec: &mut vector<u64>, index: u64):u64 {
    return  *Vector.borrow<u64>(freeze(move(vec)), move(index));
  }
  
  
  _insert_array_index_u64(vec: &mut vector<u64>, index: u64, value: u64) {
    let length: u64;
    let temp: u64;
    length = Vector.length<u64>(freeze(copy(vec)));
    Vector.push_back<u64>(copy(vec), move(value));
    if (copy(length) == copy(index)) {
      Vector.swap<u64>(copy(vec), copy(index), copy(length));
      temp = Vector.pop_back<u64>(copy(vec));
      _ = move(temp);
    };
    _ = move(vec);
    return;
  }
  
  
  _insert_array_index_bool(vec: &mut vector<bool>, index: u64, value: bool) {
    let length: u64;
    let temp: bool;
    length = Vector.length<bool>(freeze(copy(vec)));
    Vector.push_back<bool>(copy(vec), move(value));
    if (copy(length) == copy(index)) {
      Vector.swap<bool>(copy(vec), copy(index), copy(length));
      temp = Vector.pop_back<bool>(copy(vec));
      _ = move(temp);
    };
    _ = move(vec);
    return;
  }
  
  Quartz_Self_Create_Libra(input: LibraCoin.T) : Self.Libra {
    return Self.Libra_produce(move(input));
  }
  
  public Libra_Coin_init(zero: address): Self.Libra_Coin {
    if (move(zero) != 0x0) {
      assert(false, 9001);
    }
    return Libra_Coin {
      coin: LibraCoin.zero()
    };
  }
  
  public Libra_Coin_getValue(this: &mut Self.Libra_Coin): u64 {
    let coin: &LibraCoin.T;
    coin = &move(this).coin;
    return LibraCoin.value(move(coin));
  }
  
  public Libra_Coin_withdraw(this: &mut Self.Libra_Coin, amount: u64): Self.Libra_Coin {
    let coin: &mut LibraCoin.T;
    coin = &mut move(this).coin;
    return Libra_Coin {
      coin: LibraCoin.withdraw(move(coin), move(amount))
    };
  }
  
  public Libra_Coin_transfer(this: &mut Self.Libra_Coin, other: &mut Self.Libra_Coin, amount: u64) {
    let coin: &mut LibraCoin.T;
    let other_coin: &mut LibraCoin.T;
    let temporary: LibraCoin.T;
    coin = &mut move(this).coin;
    temporary = LibraCoin.withdraw(move(coin), move(amount));
    other_coin = &mut move(other).coin;
    LibraCoin.deposit(move(other_coin), move(temporary));
    return;
  }
  public Libra_Coin_transfer_value(this: &mut Self.Libra_Coin, other: Self.Libra) {
    let coin: &mut LibraCoin.T;
    let temp: Self.Libra_Coin;
    let temporary: LibraCoin.T;
    coin = &mut move(this).coin;
    Libra {temp} = move(other);
    Libra_Coin {temporary} = move(temp);
    LibraCoin.deposit(move(coin), move(temporary));
    return;
  }
  
  public Libra_Coin_send(coin: &mut Self.Libra_Coin, payee: address, amount: u64) {
    let temporary: LibraCoin.T;
    let coin_ref: &mut LibraCoin.T;
    coin_ref = &mut move(coin).coin;
    temporary = LibraCoin.withdraw(move(coin_ref), move(amount));
    LibraAccount.deposit(copy(payee), move(temporary));
    return;
  }
  
  Libra_Coin_produce (input: LibraCoin.T): Self.Libra_Coin {
    return Libra_Coin {
      coin: move(input)
    };
  }
  
  Libra_produce (input: LibraCoin.T): Self.Libra {
    return Libra {
      libra: Self.Libra_Coin_produce(move(input))
    };
  }
  
  Libra_init (): Self.Libra {
    return Self.publicLibra();
  }
  
  Quartz_Libra_send (this: &mut Self.Libra, _payee: address, _amount: u64)  {
    let _temp__5: &mut Self.Libra_Coin;
    _temp__5 = &mut copy(this).libra;
    Self.Libra_Coin_send(copy(_temp__5), copy(_payee), copy(_amount));
    _ = move(_temp__5);
    _ = move(this);
    return;
  }
}

